Hereâ€™s a `README.md` structured similarly to the examples you've shared, providing explanations for each algorithm and including a comparison table of results.

---

# Traveling Salesman Problem (TSP)

This repository contains implementations of different algorithms to solve the Traveling Salesman Problem (TSP) using a dataset of cities with latitude and longitude coordinates. We compare the performance of the Greedy Algorithm, Simulated Annealing, and a Genetic Algorithm in terms of path cost and execution time.

## Algorithms Implemented

### 1. Greedy Algorithm
The Greedy Algorithm constructs a path by always choosing the nearest unvisited city. While this approach is computationally efficient, it does not guarantee an optimal solution as it only considers local distance minimization.

- **Result**: The Greedy Algorithm provides a quick but suboptimal path. The resulting path length is generally higher compared to other, more sophisticated algorithms.
- **Algorithmic Decision**: This algorithm is chosen as a baseline due to its simplicity and speed. Despite its limitations, it offers a useful starting solution that can be optimized further.

### 2. Simulated Annealing
Simulated Annealing is a metaheuristic inspired by the annealing process in metallurgy. This algorithm accepts both improvements and, with decreasing probability, worse solutions to avoid local minima. The likelihood of accepting worse solutions decreases as the algorithm "cools."

- **Result**: Compared to the Greedy Algorithm, Simulated Annealing generally yields shorter paths, closer to the optimal solution. The trade-off is increased computation time due to the iterative cooling process.
- **Algorithmic Decision**:
  - **Initial Temperature**: A high initial temperature allows extensive exploration of the solution space.
  - **Cooling Rate**: A gradual cooling rate narrows the solution space, allowing the algorithm to converge.
  - **Minimum Temperature**: Defines the stopping point, ensuring convergence to a stable solution.

### 3. Genetic Algorithm
The Genetic Algorithm mimics natural evolution by creating a population of solutions and iteratively improving them through selection, crossover, and mutation.

- **Result**: The Genetic Algorithm produces competitive results, often yielding paths similar or superior to those from Simulated Annealing. However, it requires significant computation time, particularly with larger populations or higher generation counts.
- **Algorithmic Decision**:
  - **Population Size**: A larger population provides greater diversity, helping avoid local optima.
  - **Selection Method**: Tournament selection favors fitter paths, maintaining population diversity.
  - **Mutation**: Random mutations introduce diversity, preventing premature convergence.
  - **Generations**: A higher number of generations enables further refinement of solutions.

## Code Structure

- **Data Loading**: Reads city data from CSV files and calculates a distance matrix.
- **Greedy Algorithm**: Provides a fast, initial solution by selecting the nearest unvisited city.
- **Simulated Annealing**: Optimizes the initial path by exploring a wider solution space.
- **Genetic Algorithm**: Evolves a population of paths to approximate an optimal solution.
- **Visualization**: Plots the paths generated by each algorithm for comparison.

## Results Summary

The table below shows a comparison of path costs and execution times for each algorithm:

| Algorithm            | Path Cost (km) | Execution Time (s) |
|----------------------|----------------|---------------------|
| Greedy               | 4436.03        | 0.0020             |
| Simulated Annealing  | 4436.03        | 0.0895             |
| Genetic Algorithm    | 9412.27        | 1.6028             |

